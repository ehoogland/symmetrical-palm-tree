
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { baseUrl } from '../../../app/shared/baseUrl';
import { mapImageURL } from '../../../utils/mapImageURL';

/**
 * Fetch promotions from the server
 * @async The Redux thunk action creator function fetches the promotions data asynchronously.
 * async will wrap in a promise any response that is not a promise
 * @description action to fetch the list of promotions from the server
 * and map the image URLs.
 * @return {Promise} - A promise that resolves to the array of promotions or throws an error message.
 * It returns into the value of fetchPromotions a type of function that Redux
 * refers to as a "Redux thunk action creator".
 * @exports {Function} fetchPromotions -- the function is exported for use in other parts of the application
*/

export const fetchPromotions = createAsyncThunk(
    'promotions/fetchPromotions',
    async () => {
        const response = await fetch(baseUrl + 'promotions');
        if (!response.ok) {
            throw new Error('Failed to fetch promotions');
        }
        /** 
         * If we get here, the response was successful and we can extract the JSON data from it.
         * @response response.json() is built into the fetch API, and it will try to convert the 
         * response body from JSON (JavaScript Object Notation) format to JavaScript object format.
         * @returns {Promise} - A promise that resolves to the array of promotions.
        */
       const data = await response.json();
       return data;
    }

    /** Further JSDoc type comments will come after the relevant function */
);
// Set up the initial state [object]for the promotions slice
const initialState = {
  promotionsArray: [],
  isLoading: false,
  errMsg: '' // set to error message if fetch fails. Initially empty.
};

const promotionsSlice = createSlice({
    name: 'promotions',
    initialState,
      reducers: {
        // standard reducer logic, with auto-generated action types per reducer
        // allow manual seeding/updating of promotions in tests or dev
        // setPromotions(state, action) {
        // state.promotionsArray = action.payload;
      },
      extraReducers: { // Use computed property name syntax
        [fetchPromotions.pending]: (state) => {
          state.isLoading = true; // immer in Redux toolkit converts "mutating" code to safe immutable updates.
          // We don't actually change the state directly, but create a new state object based on the changes we make to state here.
        },
        [fetchPromotions.fulfilled]: (state, action) => {
          state.isLoading = false;
          state.errMsg = '';
          // Accept either an array or an object with a `promotions` array.
          const payload = Array.isArray(action.payload)
            ? action.payload
            : (action.payload && action.payload.promotions) || [];
          state.promotionsArray = mapImageURL(payload);
        },
        [fetchPromotions.rejected]: (state, action) => {
          state.isLoading = false; // non-mutating update
          state.errMsg = action.error ? action.error.message : 'Fetch failed'; // Provide a default error message if action.error is undefined
        } 
      }
});
/** 
 * @notes regarding createSlice
 * It is used to create a configuration object/slice object for the promotions slice of the Redux store.
 * The object passed to createSlice contains the name of the slice,the initial state, and the reducers for the slice.
 * Remember to update the state and reducers as needed.
 * Case reducers generate functions that handle specific actions and update the state accordingly.
 * They must be pure functions, meaning they should not have side effects or modify the state directly. Redux toolkit's 
 * immer library handles immutability under the hood.
 * Instead of modifying the state directly, they return a new state object that represents the updated state.
 * Case reducers are typically defined as "slice" reducers, which means they only affect the state
 * managed by their specific slice of the Redux store.
 * Recall that case/slice reducers generated by the extraReducers property will not generate a
 * corresponding action creator automatically. Instead, they must be defined manually.
 */

/**
 * Select featured partners from the Redux state
 * @param {Object} state - The Redux state
 * @returns {Array} - The array of featured promotions
 *
 * Sets the value of selectFeaturedPromotion const to an arrow function that
 * finds the first promotion with a truthy featured property
 * from the PROMOTIONS array of objects, returns that promotion object, and exports it.
 */


// Export the generated action so other parts of the app can update promotions if needed.
export const { setPromotions } = promotionsSlice.actions;

// Export the promotions reducer
export const promotionsReducer = promotionsSlice.reducer;

/**
 * Selectors
 */
export const selectAllPromotions = (state) => state.promotions.promotionsArray;

export const selectFeaturedPromotion = (state) => {
  return {
    featuredItem: state.promotions.promotionsArray.find(
      (promotion) => promotion.featured
    ),
    isLoading: state.promotions.isLoading,
    errMsg: state.promotions.errMsg
  };
};

export const selectPromotionById = (id) => (state) =>
  state.promotions.promotionsArray && state.promotions.promotionsArray.find((promotion) => promotion.id === parseInt(id));