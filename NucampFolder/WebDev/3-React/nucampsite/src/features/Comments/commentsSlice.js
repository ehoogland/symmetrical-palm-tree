import { createSlice } from '@reduxjs/toolkit';
import { COMMENTS } from '../../app/shared/COMMENTS';

// at this point we are still using the data from the local COMMENTS.js file.
// Later we will update all the slices to request and receive data from a server
const initialState = {
    commentsArray: COMMENTS
};
/**
 * Comments slice variable for managing comments state.
 * Requires the use of createSlice from Redux Toolkit (import { createSlice } from '@reduxjs/toolkit').
 * This 'configuration object' that is the value of createSlice contains the initial state
 * and reducers for comments, as well as an array of comments.
 * We call this the object passed back from createSlice, as the return value bound to
 * commentsSlice will has a method on it that is the reducer for the entire commentsSlice
 * of the state.
 * @module commentsSlice
 * @param {Object} state - The current state of the comments slice.
 * @function commentsSlice
 * @var {Object} commentsSlice
 * @property {Object} initialState - The initial state for the comments slice.
 * @property {Array} initialState.commentsArray - The array of comments for the comments slice.
 * @property {Function} commentsSlice.reducer - The reducer function for the comments slice.
 * @property {Object} reducers - The object containing all case reducers for the comments slice.
 * @method {Function} addComment - Case reducer to add a comment to the comments array.
 * @method {Function} removeComment - Case reducer to remove a comment from the comments array.
 * @exports {Function} commentsReducer
 */
const commentsSlice = createSlice({
    name: 'comments',
    initialState,
    reducers: {
        addComment: (state, action) => {
            // console.log('addComment action: ', action.payload);
            // console.log('addComment state.commentsArray: ', state.commentsArray);
            const newComment = {
                id: state.commentsArray.length + 1,
                /** 
                 * Use the spread operator to spread the properties from action.payload
                 * into the newComment object. This allows us to easily add new properties
                 * to the comment object in the future without modifying this code
                 */
                ...action.payload
            };
            /**  
             * Use the push method to add the new comment to the commentsArray since React 
             * uses immer (== 'always' in German) under the hood along with React Toolkit to make immutable
             * state updates easier and more intuitive.
             */
            state.commentsArray.push(newComment);
            // console.log('addComment state.commentsArray after push: ', state.commentsArray);

        },
        removeComment: (state, action) => {
            state.commentsArray = state.commentsArray.filter(comment => comment.id !== action.payload);
        }
    }
});
/**
 * Comments reducer for managing comments state.
 * This reducer will handle actions related to comments.
 * @param {Object} state - The current state of the comments slice.
 * @method {Function} commentsSlice.reducer
 * @var {Object} commentsSlice
 * @exports {Function} commentsReducer
 */
export const commentsReducer = commentsSlice.reducer;
/**
 * Destructure action creators for the comments slice. Action creators are functions
 * that return action objects. They are typically used in components to dispatch actions.
 * They are automatically generated by createSlice and are available on the slice object.
 */
export const { addComment } = commentsSlice.actions;
/**
 * Select comments by campsite ID from the Redux state.
 * @param {number} campsiteId - The ID of the campsite to filter comments by.
 * @returns {Array} - An array of comments associated with the specified campsite ID.
 * @exports {Function} selectCommentsByCampsiteId
 */
export const selectCommentsByCampsiteId = (campsiteId) => (state) => {
    // Filter comments to return only those that match the given campsiteId
    // This function operates directly on the imported COMMENTS data so it can
    // be called without useSelector in components that initialize local state.
    return state.comments.commentsArray
.filter(comment => comment.campsiteId === parseInt(campsiteId));
};