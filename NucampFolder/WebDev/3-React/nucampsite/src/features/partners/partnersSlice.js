import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
// import { PARTNERS } from '../../app/shared/PARTNERS'; -no longer using this local data
import { baseUrl } from '../../app/shared/baseUrl';
import { mapImageURL } from '../../utils/mapImageURL';
/**
 * Fetch partners from the server
 * @description action to fetch the list of partners from the server 
 * and map the image URLs.
 * @fetch If the fetch fails, the promise is rejected with an error message 
 * including the status code
 * @fetch If the fetch is successful, the promise is resolved with the array of partners
 * @exports {Function} fetchPartners -- the function is exported for use in other parts of the application
 * @returns {Promise} - A promise that resolves to the array of partners. 
 * @note async will wrap in a promise any response that is not a promise
 * @createAsyncThunk @return The call to createAsyncThunk() will 
 * @return into the value of fetchPartners a type of function that Redux 
 * refers to as a "Redux thunk action creator".
 * @async The Redux thunk action creator function fetches the partners data 
 * in an asynchronous way.
 */
export const fetchPartners = createAsyncThunk(
  'partners/fetchPartners', // The action type used to identify this action and 
  // set up the related action names and reducers
  async () => {
    // Fetch partners from the server
    // Contains the logic to handle the json server request and response
    // Note that json-server is used as a mock API for development
    // Set up constant variable to contain the value when the fetch call is resolved
    // If the response is not ok, the promise is rejected with an error message
    // If the response is successful, the promise is resolved with the array of partners
    const response = await fetch(baseUrl + 'partners');
    if (!response.ok) { // if falsy
        return Promise.reject('Unable to fetch, status: ' + response.status);
    }
    // If the response is successful, the promise is resolved with the array of partners
    // response.json() is built into the fetch API, and it will try to convert the response
    // body from JSON (JavaScript Object Notation) format to JavaScript object format.
    const data = await response.json();
    return data;
  }
);
  // set up the initial state [object] for the partners slice
  const initialState = {
    partnersArray: [],
    isLoading: true,
    errMsg: ''   // since we don't initially have any error messages
};
/** 
 * createSlice is used to create a configuration object
 * for the partners slice of the Redux store.
 * The object passed to createSlice contains the name of the slice,
 * the initial state, and the reducers for the slice.
 *
 * @module partnersSlice
 * This module contains the Redux slice for managing partners data.
 * Remember to update the state and reducers as needed.
 * Case reducers generate functions that handle specific actions and update the state accordingly.
 * They must be pure functions, meaning they should not have side effects or modify the state directly.
 * Instead, they should return a new state object that represents the updated state.
 * Case reducers are typically defined as "slice" reducers, which means they only affect the state
 * managed by their specific slice of the Redux store.
 * Recall that case/slice reducers generated by the extraReducers property will not generate a
 * corresponding action creator automatically. Instead, they must be defined manually.
 */
const partnersSlice = createSlice({
  name: 'partners',
  initialState,
  reducers: {},
  extraReducers: {
    [fetchPartners.pending]: (state) => {
      state.isLoading = true;
    },
    [fetchPartners.fulfilled]: (state, action) => {
      state.isLoading = false;
      state.errMsg = '';
      state.partnersArray = mapImageURL(action.payload);
      // Map image paths to full URLs based on baseUrl so the browser
      // will request images from the API server (not the frontend origin).
      // state.partnersArray = action.payload; --- IGNORE ---
    },
    [fetchPartners.rejected]: (state, action) => {
      state.isLoading = false;
      state.errMsg = action.error ? action.error.message : 'Fetch failed';
    } 
  }
});


/**
 * When the following functions are called back by React's useSelector,
 * useSelector has access to the Redux store state, and useSelector will pass
 * the global state variable to selectAllPartners.
 *
 * selectFeaturedPartner will receive it via their parameter list (state), and then
 * use state.partners.partnersArray for its return value.
*/
// Update all of the partners selector functions to use Redux state

/** 
 * @description Select and export all partners
 * @param {Object} state - The Redux state
 * @returns {Array} - The array of all partners
 */
export const selectAllPartners = (state) => {
  return state.partners.partnersArray;
};
/**
 * Select featured partners from the Redux state
 * @param {Object} state - The Redux state
 * @returns {Array} - The array of featured partners
 *
 * Sets the value of selectFeaturedPartner const to an arrow function that
 * finds the first partner with a truthy featured property
 * from the PARTNERS array of objects, returns that partner object, and exports it.
 */
export const selectFeaturedPartner = (state) => {
    return state.partners.partnersArray.find(partner => partner.featured);
};
/**
 * [F]ind is a higher-order function that returns the first element in the array
 * that satisfies the provided testing function. In this case, it returns the partner
 * with the matching id. If no partner is found, it returns undefined.
 * This function takes a callback function as its argument. This pure function
 * does not modify the state or have any side effects.
     * To write the function and export it at the same time, 
     * use the following syntax:
     */
 
export const selectPartnerById = (id) => (state) => {
    return state.partners.partnersArray.find(partner => partner.id === parseInt(id));
};
export const partnersReducer = partnersSlice.reducer;
